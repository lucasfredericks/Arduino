/*****************************************************************
  This is the final code for the Sciencenter's Energy Lab windmills.
  Each windmill has an Arduino Fio in its base that measures the voltage
  being generated by the windmill and sends it to a central hub xbee.
  The central xbee simply passes through this data to a program written in Processing
  that parses the windmill id and updates the voltage variable.
*****************************************************************/
// We'll use SoftwareSerial to communicate with the XBee:
#include <SoftwareSerial.h>
#include <avr/wdt.h>
#include <avr/sleep.h>
#include <avr/io.h>
#include <avr/interrupt.h>

// XBee's DOUT (TX) is connected to pin 2 (Arduino's Software RX)
// XBee's DIN (RX) is connected to pin 3 (Arduino's Software TX)
SoftwareSerial XBee(2, 3); // RX, TX

const int XBeeSleep = 4; // Connect to XBee DTR for hibernation mode
// calculated voltage
float R1 = 100.0;    //resistor 1 value (Kohms)
float R2 = 100.0;    //resistor 2 value (Kohms)
float dividerAdj = (R2 / (R1 + R2));
float voltage;
float lastVoltage; //comparison value to reduce noise
String wmid = "WM2/"; //CHANGE THE INTEGER TO MATCH THE WINDMILL IDENTITY e.g. "WM1/" or "WM2/" Everything else can stay the same between windmills.

void setup()
{
  // Set up both ports at 9600 baud. This value is most important
  // for the XBee. Make sure the baud rate matches the config
  // setting of your XBee.
  XBee.begin(9600);
  Serial.begin(9600);
  analogReference(INTERNAL); // changes voltage reference to 1.1 (instead of 3.3), increasing resolution of measurement
  pinMode(XBeeSleep, OUTPUT);
  voltage = 0.0;
  lastVoltage = 0.0;
  //set digital pins for low power consumption
  for (int i = 0; i < 14; i++) {
    pinMode(i, OUTPUT);
    digitalWrite(i, LOW);
  }
  digitalWrite(XBeeSleep, 0); // Enable XBee
  digitalWrite(XBeeSleep, 1); // Disable XBee
}

void loop() {
  //measure the voltage at analog pin 1
  voltage = analogRead(A1);

  //convert from bits (bytes? idk don't hire an english major next time I guess) to volts
  voltage = (voltage * (1.1 / 1.024));

  //find pre-divider9 voltage:
  //voltage = voltage/dividerAdj;
  //  if (voltage < 0.02) {
  //    voltage = 0;
  //  }

  //check to see if value has changed since last cycle:
  if (voltage != lastVoltage) {

    digitalWrite(XBeeSleep, 0);           // wake up XBee
    delay(15);                            // Give XBee time to boot up
    // send voltage for display on Serial Monitor
    Serial.print(wmid);
    Serial.print(voltage);
    Serial.println(",");
    XBee.write(Serial.read());
    digitalWrite(XBeeSleep, 1); // sleep XBee
    lastVoltage = voltage; //update lastVoltage for comparison next cycle
  }
  Serial.flush();

  wdt_reset();                         // Get ready to sleep Arduino
  watchdogEnable();                    // Turn on the watchdog timer -- this runs even while the arduino is asleep
  sleepNow();                         // Go to sleep, watchdog timer will wake later

}

void watchdogEnable() {                // Turn on watchdog timer;
  cli();
  MCUSR = 0;
  WDTCSR |= B00011000;
  //WDTCSR = B01000111;                // 2 Second Timeout
  //WDTCSR = B01100000;                // 4 Second Timeout
  //WDTCSR = B01100001;                // 8 Second Timeout
  //WDTCSR = B01000100;                 // .25 Second Timeout
  WDTCSR = B01000011;                 // .125 Second Timeout
  sei();
}

void sleepNow()
{
  /* Now is the time to set the sleep mode. In the Atmega8 datasheet
     http://www.atmel.com/dyn/resources/prod_documents/doc2486.pdf on page 35
     there is a list of sleep modes which explains which clocks and
     wake up sources are available in which sleep modes.

     In the avr/sleep.h file, the call names of these sleep modus are to be found:

     The 5 different modes are:
         SLEEP_MODE_IDLE         -the least power savings
         SLEEP_MODE_ADC
         SLEEP_MODE_PWR_SAVE
         SLEEP_MODE_STANDBY
         SLEEP_MODE_PWR_DOWN     -the most power savings

      the power reduction management <avr/power.h>  is described in
      http://www.nongnu.org/avr-libc/user-manual/group__avr__power.html
  */

  set_sleep_mode(SLEEP_MODE_STANDBY); // Sleep mode is set here

  sleep_enable();                      // Enables the sleep bit in the mcucr register
  // so sleep is possible. just a safety pin
  sleep_mode();                        // Here the device is actually put to sleep!!
  // THE PROGRAM CONTINUES FROM HERE AFTER WAKING UP
  sleep_disable();                     // Dirst thing after waking from sleep:
  // disable sleep...
}

ISR (WDT_vect) {                       // WDT Wakeup
  cli();
  wdt_disable();
  sei();
}
